# Задание

Задание проверяет понимание технологий и умение это понимание применять на практике на базе вашего существующего опыта.

Репозиторий содержит некоторе решение некоторой задачи. И задача и решене здесь приведены
только для наглядности. Ответ на каждый вопрос принимается исключительно про ваш реальный опыт над реальным проектом.
Мы ожидаем развернутых ответов.

Решением задания будет написание ответов на вопросы ниже. Ответ можно отправить в свободной форме.

## Аутентификация

Для аутентификации в этом репозитории используется jwt токен. Технология известная, зарекомендовавшая себя.
Давайте в ней усомнимся. Как минимум - в целесообразности гонять в каждом http запросе такой большой кусок данных.
Расскажите о проектах с вашим участием, где использовалась другая техника авторизации.
Если в таких проектах вы бы могли выбирать - выбрали бы вы аутентификацию через jwt? Если да, то почему?
В каком проекте, в котором вы участвовали, вы бы наоборот, вместо jwt выбрали что-то другое и почему?

- В проекте интернет-магазина мы использовали гибридную схему через OAuth2-провайдеров (Google/Facebook). Для фронтенда мы использовали сессионные ID. Это для компактности и безопасности: если аккаунт пользователя нужно быстро заблокировать. Если бы я выбирал для админки, я бы оставил JWT, так как там меньше пользователей и проще архитектура, но для клиентского приложения сессиионные токены надежнее для контроля доступа

## Идентификация

В этом репозтории в некоторых таблицах для идентификации записи используется uuid. Эта техника удобна по нескольким параметрам.
Сложно представить, чтобы использование uuid во всех таблицах - как стандарта - создало бы где нибудь проблему.
Но может быть в вашей практике встречались случаи, где uuid как идентификатор стал проблемой или мог бы стать проблемой?
Опишите где и почему.

- Хотя я больше специализируюсь на фронтенде, мы обсуждали риски UUID. Основная проблема — это случайность генерации. В базах данных это ведет к фрагментаци, замедляет запись и увеличивает нагрузку на диск. Кроме того, UUID занимает больше памяти, что в больших базах заметно влияет на скорость, а также создает пробелмы с кэшированием

## Организация кода

В этом репозитории, серверный код сделан на базе NestJS.
DI, services, controllers, middleware, decorators - в этом, как и во многих других подходах есть плюсы и выгоды.
Расскажите с примерами из опыта о реальной пользе того или иного механизма организации кода лично для вас или
для вашей команды, а может быть - для компании. Если есть какой-то механим, который также - для вас, команды
или компании наоборот - создавал сложности - тоже расскажите.

- Я использовал Angular, думаю, это похоже во многом на NestJS. Сложность бывает когда декораторы и middleware используются там, где достаточно простой функции, что усложняет отладку. Лучше просто договорися где что используется чтобы избежать таких проблем.

## Реактивность

В этом репозитории, для интерфейса используется React. Его название связано с реактивным подходом к отрисовке
интерфейса - мы меняем состояние, а интерфейс перерисовывается в соответствии с этим.
Сам посыл подкупает - разработчик заботится о состоянии, остальное за него делает фреймворк.
Такой подход, конечно, помимо React реализуют и многие другие фреймворки.
Были ли ситуации в вашем опыте, когда реактивность была не плюсом, а помехой? Если да, расскажите на примере.
Если был опыт построения рендера интерфеса на другом принципе, раскажите на каком и какие были резльтаты?
Расскажите на конкретных примерах, что вам доставляет неудобства в том, как реактивность реализована
непосредственно во фреймворке React?

- В React может возникать избыточный рендеринг если не использовать useMemo, useCallback. Таке, рендеринг на фронте создает проблемы для SEO, так как поисковики не знают об изменениях. Тут лучше использовать серверный или гибридный рендеринг. Касаемо альтернатив: в библиотеках типа HTMX реактивность переносится на сервер и мы получаем SEO-дружелюбный контент сразу в HTML при первом рендеринге, и меньше JS-кода на фронте
